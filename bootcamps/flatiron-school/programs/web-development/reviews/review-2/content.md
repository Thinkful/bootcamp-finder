Six weeks into the Flatiron program, we have just begun using Rails and I
couldn’t be happier about it. Specific to this post, I am excited to
understand what is going on in the background of Rails’ magical generate tasks
and it’s use of ActiveRecord metaprogramming. In the six weeks up until this
point, we have gone over a great deal of the core functionality without even
actually realizing what we were doing: We began with simple Ruby code, we
wrapped things up in classes, we wrote out our own sqlite scripts, built MVC
frameworks from the ground up with Sinatra, and now we’re using Rails, which
does most of these things for you. I’ve described elements of programming
through a metaphor of the building industry in my last post, and I don’t want
to hammer (heh heh) the issue too far, but I’m going to give a nice little
anecdotal memory that pairs nicely with what is going on in the program now.
When I first began working under a general contractor, one of the more
interesting, though frustrating moments was building a barn with two of my
friends, using nothing but good ol fashioned hammers and nails. It took so
long! My hands were so blistered! There were better, more powerful tools for
the job, hell they were even on the jobsite, but we had orders, and so there
we were, just swinging away like uncivilized heathens. Ultimately, we built
the thing, and my appreciation of modern building methods had grown
tremendously. This was nine years ago, and I don’t imagine I will ever forget
the importance of that process. A classmate recently compared our work these
past weeks as ‘waxing off’, practicing these seemingly rote tasks that we are
now realizing have built the best kind of foundation for our work with Rails.
Having written out sql statements by hand, hard-coding all the foreign-key
dependencies, not only is it incredibly awesome to run a rails generate
migration, or a rake db:migrate command, but I know almost exactly what is
going on under the hood at these moments, and if the need ever arose, I would
have little hesitation of getting in there and hard-coding once again. A
foundational understanding of these processes makes for a much better use of a
tool as high-powered as Rails. Its like, imagine for a moment that you had no
understanding of how to open a door. On the day that you finally discover it’s
secret, you happen to be wearing jeans. For how long would you assume a
correlation, or even causation between your outfit and the door’s
functionality? It’s like how if a pigeon is fed, and it happened to have
turned in a circle beforehand, studies have shown that it will repeat this
task in the hopes of it helping it acrue more food. It’s silly, but only to
the extent to which we can comprehend the actual underlying processes. At the
end of it, it’s really the difference of ritual and method. In Rails, I feel
like I now know what its metaprogramming is creating and why it’s beneficial.
I feel like I can actually use this stuff. - a Flatiron student

